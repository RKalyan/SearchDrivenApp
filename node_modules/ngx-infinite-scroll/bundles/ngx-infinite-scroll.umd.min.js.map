{"version":3,"file":"ngx-infinite-scroll.umd.min.js","sources":["../../src/services/ngx-ins-utils.ts","../../src/services/event-trigger.ts","../../src/services/position-resolver.ts","../../src/services/scroll-resolver.ts","../../src/services/scroll-register.ts","../../src/services/axis-resolver.ts","../../src/modules/infinite-scroll.directive.ts","../../src/modules/ngx-infinite-scroll.module.ts"],"sourcesContent":["import * as console from 'console';\nimport { ElementRef, SimpleChange } from '@angular/core';\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nexport function resolveContainerElement(\n  selector: string | any,\n  scrollWindow,\n  defaultElement,\n  fromRoot: boolean\n): any {\n  const /** @type {?} */ hasWindow = window && !!window.document && window.document.documentElement;\n  let /** @type {?} */ container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    const /** @type {?} */ containerIsString =\n      selector && hasWindow && typeof selector === 'string';\n    container = containerIsString\n      ? findElement(selector, defaultElement.nativeElement, fromRoot)\n      : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nexport function findElement(\n  selector: string | any,\n  customRoot: ElementRef | any,\n  fromRoot: boolean\n) {\n  const /** @type {?} */ rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nexport function inputPropChanged(prop: SimpleChange): boolean {\n  return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nexport function hasWindowDefined(): boolean {\n  return typeof window !== 'undefined';\n}\n","import { InfiniteScrollEvent, IPositionStats } from '../models';\n\nexport interface IScrollerProps {\n  container: IPositionStats;\n  down: number;\n  up: number;\n  alwaysCallback: boolean;\n  disabled: boolean;\n}\n\nexport interface ITriggerEvents {\n  down: (event: any) => any;\n  up: (event: any) => any;\n}\n\nexport interface IDistanceRange {\n  down: number;\n  up: number;\n}\n\nexport interface IScrollConfig {\n  alwaysCallback: boolean;\n  shouldFireScrollEvent: boolean;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nexport function shouldTriggerEvents({ alwaysCallback, shouldFireScrollEvent }: IScrollConfig) {\n  return (alwaysCallback || shouldFireScrollEvent);\n}\n/**\n * @param {?} callbacks\n * @param {?} isScrollingDown\n * @param {?} scrolledUntilNow\n * @return {?}\n */\nexport function triggerEvents(\n  callbacks: ITriggerEvents,\n  isScrollingDown: boolean,\n  scrolledUntilNow: number\n) {\n  const /** @type {?} */ eventData: InfiniteScrollEvent = {\n    currentScrollPosition: scrolledUntilNow\n  };\n  const /** @type {?} */ callback = isScrollingDown ? callbacks.down : callbacks.up;\n  callback(eventData);\n}\n","import { ElementRef } from '@angular/core';\n\nimport { ContainerRef, IPositionElements, IPositionStats, IResolver } from '../models';\nimport { AxisResolver } from './axis-resolver';\n/**\n * @param {?} __0\n * @return {?}\n */\nexport function createResolver({\n  windowElement,\n  axis\n}: IPositionElements): IResolver {\n  return createResolverWithContainer(\n    { axis, isWindow: isElementWindow(windowElement) },\n    windowElement\n  );\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nexport function createResolverWithContainer(\n  resolver,\n  windowElement: ContainerRef\n) {\n  const /** @type {?} */ container =\n    resolver.isWindow || (windowElement && !windowElement.nativeElement)\n      ? windowElement\n      : windowElement.nativeElement;\n  return { ...resolver, container };\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nexport function isElementWindow(windowElement: ContainerRef): boolean {\n  const /** @type {?} */ isWindow = ['Window', 'global'].some((obj: string) =>\n    Object.prototype.toString.call(windowElement).includes(obj)\n  );\n  return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nexport function getDocumentElement(isContainerWindow: boolean, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nexport function calculatePoints(element: ElementRef, resolver: IResolver) {\n  const /** @type {?} */ height = extractHeightForElement(resolver);\n  return resolver.isWindow\n    ? calculatePointsForWindow(height, element, resolver)\n    : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nexport function calculatePointsForWindow(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container, isWindow } = resolver;\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  const /** @type {?} */ scrolledUntilNow =\n    height +\n    getElementPageYOffset(\n      getDocumentElement(isWindow, container),\n      axis,\n      isWindow\n    );\n  // total height / most bottom y point\n  const /** @type {?} */ nativeElementHeight = getElementHeight(\n    element.nativeElement,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n  const /** @type {?} */ totalToScroll =\n    getElementOffsetTop(element.nativeElement, axis, isWindow) +\n    nativeElementHeight;\n  return { height, scrolledUntilNow, totalToScroll };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nexport function calculatePointsForElement(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  const /** @type {?} */ scrolledUntilNow = container[axis.scrollTopKey()];\n  const /** @type {?} */ totalToScroll = container[axis.scrollHeightKey()];\n  return { height, scrolledUntilNow, totalToScroll };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nexport function extractHeightPropKeys(axis: AxisResolver) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nexport function extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}: IResolver) {\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  return getElementHeight(\n    container,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nexport function getElementHeight(\n  elem: any,\n  isWindow: boolean,\n  offsetHeightKey: string,\n  clientHeightKey: string\n) {\n  if (isNaN(elem[offsetHeightKey])) {\n    return getDocumentElement(isWindow, elem)[clientHeightKey];\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nexport function getElementOffsetTop(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const /** @type {?} */ topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return (\n    elem.getBoundingClientRect()[topKey] +\n    getElementPageYOffset(elem, axis, isWindow)\n  );\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nexport function getElementPageYOffset(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const /** @type {?} */ pageYOffset = axis.pageYOffsetKey();\n  const /** @type {?} */ scrollTop = axis.scrollTopKey();\n  const /** @type {?} */ offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window[pageYOffset])) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n","import { IPositionStats, IScrollerConfig, IScrollState } from '../models';\n/**\n * @param {?} container\n * @param {?} config\n * @param {?} scrollingDown\n * @return {?}\n */\nexport function shouldFireScrollEvent(\n  container: IPositionStats,\n  config: IScrollerConfig,\n  scrollingDown: boolean\n) {\n  const /** @type {?} */ distance = config.distance;\n  let /** @type {?} */ remaining: number;\n  let /** @type {?} */ containerBreakpoint: number;\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - container.scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    remaining = container.scrolledUntilNow / container.totalToScroll;\n    containerBreakpoint = distance.up / 10;\n  }\n\n  const /** @type {?} */ shouldFireEvent: boolean = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nexport function isScrollingDownwards(\n  lastScrollPosition: number,\n  container: IPositionStats\n) {\n  return lastScrollPosition < container.scrolledUntilNow;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} config\n * @return {?}\n */\nexport function getScrollStats(\n  lastScrollPosition: number,\n  container: IPositionStats,\n  config: IScrollerConfig\n) {\n  const /** @type {?} */ isScrollingDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    shouldFireScrollEvent: shouldFireScrollEvent(container, config, isScrollingDown),\n    isScrollingDown\n  };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\nexport function updateScrollPosition(position: number, scrollState: IScrollState) {\n  return (scrollState.lastScrollPosition = position);\n}\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\nexport function updateTotalToScroll(totalToScroll: number, scrollState: IScrollState) {\n  scrollState.lastTotalToScroll = scrollState.totalToScroll;\n  scrollState.totalToScroll = totalToScroll;\n}\n/**\n * @param {?} scrollState\n * @return {?}\n */\nexport function isSameTotalToScroll(scrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n/**\n * @param {?} scrollState\n * @param {?} triggered\n * @return {?}\n */\nexport function updateTriggeredFlag(scrollState, triggered: boolean) {\n  scrollState.isTriggeredTotal = triggered;\n}\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\nexport function updateScrollState(scrollState: IScrollState, scrolledUntilNow: number, totalToScroll: number) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState);\n  const /** @type {?} */ isSameTotal = isSameTotalToScroll(scrollState);\n  if (!isSameTotal) {\n    updateTriggeredFlag(scrollState, false);\n  }\n}\n","import'rxjs/add/observable/fromEvent';\nimport'rxjs/add/observable/of';\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/mergeMap';\nimport'rxjs/add/operator/sampleTime';\n\nimport { ElementRef } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport { ContainerRef, IPositionStats, IScrollState } from '../models';\nimport { AxisResolver } from './axis-resolver';\nimport { shouldTriggerEvents, triggerEvents } from './event-trigger';\nimport { resolveContainerElement } from './ngx-ins-utils';\nimport { calculatePoints, createResolver } from './position-resolver';\nimport * as ScrollResolver from './scroll-resolver';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\n\nexport interface IScrollRegisterConfig {\n  container: ContainerRef;\n  throttleDuration: number;\n  mergeMap: Function;\n  scrollHandler: (value: any) => void;\n}\n\nexport interface IScroller {\n  fromRoot: boolean;\n  horizontal: boolean;\n  disable: boolean;\n  throttle: number;\n  scrollWindow: boolean;\n  element: ElementRef;\n  scrollContainer: string | ElementRef;\n  alwaysCallback: boolean;\n  downDistance: number;\n  upDistance: number;\n  events?: {\n    down: (ev) => any;\n    up: (ev) => any;\n  };\n}\n/**\n * @param {?} config\n * @return {?}\n */\nexport function createScroller(config: IScroller): Subscription {\n  const { scrollContainer, scrollWindow, element, fromRoot } = config;\n  const /** @type {?} */ resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  const /** @type {?} */ stats = calculatePoints(element, resolver);\n  const /** @type {?} */ scrollState: IScrollState = {\n    lastScrollPosition: 0,\n    lastTotalToScroll: 0,\n    totalToScroll: stats.totalToScroll,\n    isTriggeredTotal: false\n  };\n  const /** @type {?} */ options: IScrollRegisterConfig = {\n    container: resolver.container,\n    mergeMap: () => calculatePoints(element, resolver),\n    scrollHandler: (positionStats: IPositionStats) =>\n      handleOnScroll(scrollState, positionStats, config),\n    throttleDuration: config.throttle\n  };\n  return attachScrollEvent(options);\n}\n/**\n * @param {?} options\n * @return {?}\n */\nexport function attachScrollEvent(\n  options: IScrollRegisterConfig\n): Subscription {\n  return Observable.fromEvent(options.container, 'scroll')\n    .sampleTime(options.throttleDuration)\n    .mergeMap((ev: any) => Observable.of(options.mergeMap(ev)))\n    .subscribe(options.scrollHandler);\n}\n/**\n * @param {?} scrollState\n * @param {?} positionStats\n * @param {?} config\n * @return {?}\n */\nexport function handleOnScroll(\n  scrollState: IScrollState,\n  positionStats: IPositionStats,\n  config: IScroller\n) {\n  const /** @type {?} */ distance = {\n    down: config.downDistance,\n    up: config.upDistance\n  };\n  const { isScrollingDown, shouldFireScrollEvent } = ScrollResolver.getScrollStats(\n    scrollState.lastScrollPosition,\n    positionStats,\n    { distance }\n  );\n  const /** @type {?} */ scrollConfig = {\n    alwaysCallback: config.alwaysCallback,\n    shouldFireScrollEvent\n  };\n  ScrollResolver.updateScrollState(scrollState, positionStats.scrolledUntilNow, positionStats.totalToScroll);\n  const /** @type {?} */ shouldTrigger = shouldTriggerEvents(scrollConfig);\n  if (shouldTrigger && !scrollState.isTriggeredTotal) {\n    ScrollResolver.updateTriggeredFlag(scrollState, true);\n    triggerEvents(\n      config.events,\n      isScrollingDown,\n      positionStats.scrolledUntilNow\n    );\n  }\n}\n","\nexport class AxisResolver {\n/**\n * @param {?=} vertical\n */\nconstructor(private vertical: boolean = true) {\n  }\n/**\n * @return {?}\n */\nclientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }\n/**\n * @return {?}\n */\noffsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }\n/**\n * @return {?}\n */\nscrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }\n/**\n * @return {?}\n */\npageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }\n/**\n * @return {?}\n */\noffsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }\n/**\n * @return {?}\n */\nscrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }\n/**\n * @return {?}\n */\ntopKey() { return this.vertical ? 'top' : 'left'; }\n}\n\nfunction AxisResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nAxisResolver.prototype.vertical;\n}\n\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  SimpleChanges\n} from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport { InfiniteScrollEvent } from '../models';\nimport { hasWindowDefined, inputPropChanged } from '../services/ngx-ins-utils';\nimport { createScroller } from '../services/scroll-register';\nexport class InfiniteScrollDirective\n  implements OnDestroy, OnChanges, AfterViewInit {\n   scrolled = new EventEmitter<InfiniteScrollEvent>();\n   scrolledUp = new EventEmitter<InfiniteScrollEvent>();\n\n   infiniteScrollDistance: number = 2;\n   infiniteScrollUpDistance: number = 1.5;\n   infiniteScrollThrottle: number = 300;\n   infiniteScrollDisabled: boolean = false;\n   infiniteScrollContainer: any = null;\n   scrollWindow: boolean = true;\n   immediateCheck: boolean = false;\n   horizontal: boolean = false;\n   alwaysCallback: boolean = false;\n   fromRoot: boolean = false;\nprivate disposeScroller: Subscription;\n/**\n * @param {?} element\n * @param {?} zone\n */\nconstructor(private element: ElementRef,\nprivate zone: NgZone) { }\n/**\n * @return {?}\n */\nngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n/**\n * @param {?} __0\n * @return {?}\n */\nngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }: SimpleChanges) {\n    const /** @type {?} */ containerChanged = inputPropChanged(infiniteScrollContainer);\n    const /** @type {?} */ disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const /** @type {?} */ distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const /** @type {?} */ shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n      (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n/**\n * @return {?}\n */\nsetup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          events: {\n            // tslint:disable-next-line:arrow-parens\n            down: event => this.zone.run(() => this.scrolled.emit(event)),\n            // tslint:disable-next-line:arrow-parens\n            up: event => this.zone.run(() => this.scrolledUp.emit(event))\n          },\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        });\n      });\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.destroyScroller();\n  }\n/**\n * @return {?}\n */\ndestroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: NgZone, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'scrolled': [{ type: Output },],\n'scrolledUp': [{ type: Output },],\n'infiniteScrollDistance': [{ type: Input },],\n'infiniteScrollUpDistance': [{ type: Input },],\n'infiniteScrollThrottle': [{ type: Input },],\n'infiniteScrollDisabled': [{ type: Input },],\n'infiniteScrollContainer': [{ type: Input },],\n'scrollWindow': [{ type: Input },],\n'immediateCheck': [{ type: Input },],\n'horizontal': [{ type: Input },],\n'alwaysCallback': [{ type: Input },],\n'fromRoot': [{ type: Input },],\n};\n}\n\nfunction InfiniteScrollDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollDirective.ctorParameters;\n/** @type {?} */\nInfiniteScrollDirective.propDecorators;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrolled;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrolledUp;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollDistance;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollUpDistance;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollThrottle;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollDisabled;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollContainer;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollWindow;\n/** @type {?} */\nInfiniteScrollDirective.prototype.immediateCheck;\n/** @type {?} */\nInfiniteScrollDirective.prototype.horizontal;\n/** @type {?} */\nInfiniteScrollDirective.prototype.alwaysCallback;\n/** @type {?} */\nInfiniteScrollDirective.prototype.fromRoot;\n/** @type {?} */\nInfiniteScrollDirective.prototype.disposeScroller;\n/** @type {?} */\nInfiniteScrollDirective.prototype.element;\n/** @type {?} */\nInfiniteScrollDirective.prototype.zone;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScrollDirective } from './infinite-scroll.directive';\nexport class InfiniteScrollModule { static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [InfiniteScrollDirective],\n  exports: [InfiniteScrollDirective],\n  imports: [],\n  providers: []\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction InfiniteScrollModule_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","findElement","nativeElement","Error","customRoot","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","shouldTriggerEvents","_a","alwaysCallback","shouldFireScrollEvent","triggerEvents","callbacks","isScrollingDown","scrolledUntilNow","eventData","currentScrollPosition","down","up","createResolver","windowElement","createResolverWithContainer","axis","isWindow","isElementWindow","resolver","Object","assign","some","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","offsetHeightKey","clientHeightKey","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","scrollTopKey","scrollHeightKey","_b","elem","isNaN","topKey","getBoundingClientRect","pageYOffset","pageYOffsetKey","scrollTop","offsetTop","offsetTopKey","ownerDocument","defaultView","config","scrollingDown","remaining","containerBreakpoint","distance","isScrollingDownwards","lastScrollPosition","getScrollStats","updateScrollPosition","position","scrollState","updateTotalToScroll","lastTotalToScroll","isSameTotalToScroll","updateTriggeredFlag","triggered","isTriggeredTotal","updateScrollState","createScroller","scrollContainer","AxisResolver","horizontal","stats","attachScrollEvent","mergeMap","scrollHandler","positionStats","handleOnScroll","throttleDuration","throttle","options","Observable","fromEvent","sampleTime","ev","of","subscribe","downDistance","upDistance","shouldFireScrollEvent$$1","scrollConfig","ScrollResolver.updateScrollState","ScrollResolver.updateTriggeredFlag","events","vertical","this","InfiniteScrollDirective","zone","scrolled","EventEmitter","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","_this","runOutsideAngular","disposeScroller","disable","event","run","emit","ngOnDestroy","unsubscribe","decorators","type","Directive","args","ctorParameters","ElementRef","NgZone","propDecorators","Output","Input","InfiniteScrollModule","NgModule","declarations","exports","imports","providers"],"mappings":"85BASA,SAAAA,yBACEC,SACAC,aACAC,eACAC,UAEA,GANMC,WAAYC,UAAYA,OAAOC,UAAYD,OAAOC,SAASC,gBAC7DC,UAAYJ,WAAaH,aAAeI,OAASH,cAOrD,IAAIF,SANU,CAYZ,KAHAQ,UADER,UANYI,WAAiC,gBAAbJ,UAE9BS,YAAYT,SAAUE,eAAeQ,cAAeP,UACpDH,UAQF,KANM,IAAIW,OAAM,iEASpB,MANOH,WAcT,QAAAC,aACET,SACAY,WACAT,UAGA,OAZeA,SAAWE,OAAOC,SAAWM,YAC9BC,cAAcb,UAiB9B,QAAAc,kBAdCC,MAeC,MAdOA,QAAQA,KAAMC,YAmBvB,QAAAC,oBACE,MAhByB,mBAAXZ,QCVhB,QAAAa,qBAHCC,IAAD,GAACC,gBAADD,GAAAC,eAACC,sBAADF,GAAAE,qBAIE,OAHOD,iBAAmBC,sBAW5B,QAAAC,eACEC,UACAC,gBACAC,kBAEA,GARMC,YASJC,sBARuBF,mBAERD,gBAAkBD,UAAUK,KAAOL,UAAUM,IACrDH,WC9BX,QAAAI,gBAHCX,IAID,GAAEY,eAAFZ,GAAAY,aAGE,OAHOC,8BACHC,KADNd,GAAAc,KACYC,SAAUC,gBAAgBJ,gBAIlCA,eAQJ,QAAAC,6BACEI,SACAL,eAEA,GAPMvB,WAQJ4B,SAPSF,UAAYH,gBAAkBA,cAAerB,cAClDqB,cACAA,cAAcrB,aAQpB,OAAF2B,QAAAC,UAPWF,UAAa5B,UAOxBA,YAMA,QAAA2B,iBAVCJ,eAcC,OAbiB,SAAW,UAAUQ,KAAK,SAACC,KAW1C,MAAAH,QAVOI,UAAUC,SAASC,KAAKZ,eAAea,SAASJ,OAmB3D,QAAAK,oBAdCC,kBAAAf,eAeC,MAdOe,mBAAoBf,cAAczB,SAASC,gBAAkB,KAqBtE,QAAAwC,iBAlBCC,QAAAZ,UAmBC,GAlBMa,QAASC,wBAAwBd,SAmBvC,OAlBOA,UAASF,SACZiB,yBAAyBF,OAAQD,QAASZ,UAC1CgB,0BAA0BH,OAAQD,QAASZ,UA0BjD,QAAAe,0BACEF,OACAD,QACAZ,UArBQ,GAAAH,MAAVG,SAAAH,KAAgBzB,UAAhB4B,SAAA5B,UAA2B0B,SAA3BE,SAAAF,SACQf,GAARkC,sBAAApB,MAAUqB,gBAAVnC,GAAAmC,gBAA2BC,gBAA3BpC,GAAAoC,gBAEQ9B,iBAwBJwB,OACAO,sBACEX,mBAvBmBX,SAAU1B,WAwB7ByB,KACAC,UApBEuB,oBAAsBC,iBAwB1BV,QAvBQtC,cAwBRwB,SACAoB,gBACAC,gBAKF,QAvBSN,OAuBXA,OAvBmBxB,iBAuBnBA,iBAvBqCkC,cAqBjCC,oBAvBoBZ,QAAQtC,cAAeuB,KAAMC,UAwBjDuB,qBASJ,QAAAL,2BACEH,OACAD,QACAZ,UA1BQ,GAAAH,MAAVG,SAAAH,KAAgBzB,UAAhB4B,SAAA5B,SAgCE,QA5BSyC,OA4BXA,OA5BmBxB,iBAFQjB,UAAUyB,KAAK4B,gBAELF,cADbnD,UAAUyB,KAAK6B,oBAmCvC,QAAAT,uBA/BCpB,MAgCC,OACEqB,gBA/BiBrB,KAAKqB,kBAgCtBC,gBA/BiBtB,KAAKsB,mBAsC1B,QAAAL,yBAlCC/B,IAmCD,GAAEX,WAAFW,GAAAX,UACE0B,SADFf,GAAAe,SAEED,KAFFd,GAAAc,KA9BQ8B,GAARV,sBAAApB,KAmCE,OAlCOyB,kBAmCLlD,UACA0B,SArCJ6B,GAAAT,gBAAAS,GAAAR,iBAiDA,QAAAG,kBACEM,KACA9B,SACAoB,gBACAC,iBAEA,MAAIU,OAzCMD,KAAKV,kBACNT,mBAAmBX,SAAU8B,MAAMT,iBAEnCS,KAAKV,iBAkDhB,QAAAM,qBACEI,KACA/B,KACAC,UAEA,GA9CMgC,QAASjC,KAAKiC,QAgDpB,IA9CKF,KAAKG,sBAkDV,MACEH,MA9CKG,wBAAwBD,QA+C7BV,sBA9CsBQ,KAAM/B,KAAMC,UAuDtC,QAAAsB,uBACEQ,KACA/B,KACAC,UAEA,GAnDMkC,aAAcnC,KAAKoC,iBACnBC,UAAYrC,KAAK4B,eACjBU,UAAYtC,KAAKuC,cAqDvB,OAAIP,OAnDM5D,OAAO+D,cACRvB,mBAAmBX,SAAU8B,MAAMM,WACrCN,KAASS,cACPT,KAAKS,cAAcC,YAAYN,aAE/BJ,KAAKO,WC7IhB,QAAAlD,uBACEb,UACAmE,OACAC,eAEA,GAJIC,WACAC,oBAFEC,SAAWJ,OAAOI,QAiBxB,OATIH,gBACFC,WALYrE,UAAWmD,cAAgBnD,UAAUiB,kBAAoBjB,UAAUmD,cAM/EmB,oBALsBC,SAASnD,KAAO,KAOtCiD,UALYrE,UAAUiB,iBAAmBjB,UAAUmD,cAMnDmB,oBALsBC,SAASlD,GAAK,IAGLgD,WAAaC,oBAahD,QAAAE,sBACEC,mBACAzE,WAEA,MATOyE,oBAAqBzE,UAAUiB,iBAiBxC,QAAAyD,gBACED,mBACAzE,UACAmE,QAEA,GAdMnD,iBAAkBwD,qBAAqBC,mBAAoBzE,UAejE,QACEa,sBAduBA,sBAAsBb,UAAWmE,OAAQnD,iBAehEA,gBAAJA,iBAQA,QAAA2D,sBAlBCC,SAAAC,aAmBC,MAlBOA,aAAaJ,mBAAqBG,SAyB3C,QAAAE,qBAtBC3B,cAAA0B,aAuBCA,YAtBYE,kBAAoBF,YAAY1B,cAuB5C0B,YAtBY1B,cAAgBA,cA4B9B,QAAA6B,qBAzBCH,aA0BC,MAzBOA,aAAY1B,gBAAkB0B,YAAYE,kBAgCnD,QAAAE,qBA7BCJ,YAAAK,WA8BCL,YA7BYM,iBAAmBD,UAqCjC,QAAAE,mBAlCCP,YAAA5D,iBAAAkC,eAmCCwB,qBAlCqB1D,iBAAkB4D,aAmCvCC,oBAlCoB3B,cAAe0B,aACfG,oBAAoBH,cAoCtCI,oBAlCoBJ,aAAa,GClBrC,QAAAQ,gBAHClB,QACS,GAAAmB,iBAAVnB,OAAAmB,gBAA2B7F,aAA3B0E,OAAA1E,aAAyC+C,QAAzC2B,OAAA3B,QAAkD7C,SAAlDwE,OAAAxE,SACQiC,SAAWN,gBAIfG,KAHM,GAAI8D,eAAcpB,OAAOqB,YAI/BjE,cAHehC,wBAAwB+F,gBAAiB7F,aAAc+C,QAAS7C,YAE3E8F,MAAQlD,gBAAgBC,QAASZ,UACjCiD,aAIJJ,mBAHoB,EAIpBM,kBAHmB,EAInB5B,cAHesC,MAAMtC,cAIrBgC,kBAHkB,EAYpB,OAHOO,oBAHL1F,UAHW4B,SAAS5B,UAIpB2F,SAHU,WAAM,MAAApD,iBAAgBC,QAASZ,WAIzCgE,cAHe,SAAAC,eAIb,MAAAC,gBAHejB,YAAagB,cAAe1B,SAI7C4B,iBAHkB5B,OAAO6B,WAW7B,QAAAN,mBACEO,SAEA,MANOC,iBAMTA,WANoBC,UAAUF,QAAQjG,UAAW,UAO5CoG,WANWH,QAAQF,kBAOnBJ,SANS,SAACU,IAAY,MAAAH,iBAM3BA,WANsCI,GAAGL,QAAQN,SAASU,OAOrDE,UANUN,QAAQL,eAcvB,QAAAE,gBACEjB,YACAgB,cACA1B,QAEA,GAXMI,WAYJnD,KAXM+C,OAAOqC,aAYbnF,GAXI8C,OAAOsC,YAEP9F,GAAR+D,eAAAG,YAAAJ,mBAAAoB,eAAAtB,SAAAA,WAAUvD,gBAAVL,GAAAK,gBAA2B0F,yBAA3B/F,GAAAE,sBAKQ8F,cAYJ/F,eAXgBuD,OAAOvD,eAYvBC,sBAAAA,yBAEF+F,mBAXiC/B,YAAagB,cAAc5E,iBAAkB4E,cAAc1C,eACtEzC,oBAAoBiG,gBACrB9B,YAAaM,mBAYhC0B,oBAXmChC,aAAa,GAYhD/D,cACEqD,OAXO2C,OAYP9F,gBACA6E,cAXc5E,mBClGpB,GAAAsE,cAAA,WAIA,QAAAA,cAJsBwB,UAAtB,SAAAA,WAAsBA,UAAtB,GAAsBC,KAAtBD,SAAsBA,SAkCtB,MAzBAxB,cAAAtD,UAAAc,gBAAA,WAPsB,MAAOiE,MAAKD,SAAW,eAAiB,eAW9DxB,aAAAtD,UAAAa,gBAAA,WAVsB,MAAOkE,MAAKD,SAAW,eAAiB,eAc9DxB,aAAAtD,UAAAqB,gBAAA,WAbsB,MAAO0D,MAAKD,SAAW,eAAiB,eAiB9DxB,aAAAtD,UAAA4B,eAAA,WAhBqB,MAAOmD,MAAKD,SAAW,cAAgB,eAoB5DxB,aAAAtD,UAAA+B,aAAA,WAnBmB,MAAOgD,MAAKD,SAAW,YAAc,cAuBxDxB,aAAAtD,UAAAoB,aAAA,WAtBmB,MAAO2D,MAAKD,SAAW,YAAc,cA0BxDxB,aAAAtD,UAAAyB,OAAA,WAzBa,MAAOsD,MAAKD,SAAW,MAAQ,QA0B5CxB,gBClBA0B,wBAAA,WAoBA,QAAAA,yBAAsBzE,QAA6B0E,MAA7BF,KAAtBxE,QAAsBA,QAA6BwE,KAAnDE,KAAmDA,KAlBhDF,KAAHG,SAEc,GAAIC,eAFlBA,aACGJ,KAAHK,WAEgB,GAAID,eAFpBA,aAEGJ,KAAHM,uBAEoC,EADjCN,KAAHO,yBAEsC,IADnCP,KAAHQ,uBAEoC,IADjCR,KAAHS,wBAEqC,EADlCT,KAAHU,wBAEkC,KAD/BV,KAAHvH,cAE2B,EADxBuH,KAAHW,gBAE6B,EAD1BX,KAAHxB,YAEyB,EADtBwB,KAAHpG,gBAE6B,EAD1BoG,KAAHrH,UAEuB,QASvBsH,yBAAAhF,UAAA2F,gBAAA,WAFSZ,KAAKS,wBAIRT,KAHKa,SAUXZ,wBAAAhF,UAAA6F,YAAA,SANGnH,IAAH,GAAG+G,yBAAH/G,GAAA+G,wBAAGD,uBAAH9G,GAAA8G,uBAAGH,uBAAH3G,GAAA2G,uBACUS,iBAAmBzH,iBAAiBoH,yBACpCM,gBAAkB1H,iBAAiBmH,wBACnCQ,gBAAkB3H,iBAAiBgH,wBACnCY,aAAgBF,kBAAmBhB,KAAMS,wBAO5CO,kBANmBP,uBAAwBU,cAAiBF,iBAQ3DF,kBANoBC,iBAAmBC,mBAOzCjB,KANKoB,kBAODF,aACFlB,KANKa,UAabZ,wBAAAhF,UAAA4F,MAAA,WAAA,GAAAQ,OAAArB,IACQvG,qBACFuG,KARKE,KAAKoB,kBAAkB,WAS1BD,MARKE,gBAAkBlD,gBASrB1F,SARU0I,MAAK1I,SASfiB,eARgByH,MAAKzH,eASrB4H,QARSH,MAAKZ,uBASdjB,aARc6B,MAAKf,uBASnB9E,QARS6F,MAAK7F,QASdsE,QAEE1F,KARM,SAAAqH,OAAS,MAAAJ,OAAKnB,KAAKwB,IAAI,WAAM,MAAAL,OAAKlB,SAASwB,KAAKF,UAUtDpH,GARI,SAAAoH,OAAS,MAAAJ,OAAKnB,KAAKwB,IAAI,WAAM,MAAAL,OAAKhB,WAAWsB,KAAKF,WAUxDjD,WARY6C,MAAK7C,WASjBF,gBARiB+C,MAAKX,wBAStBjI,aARc4I,MAAK5I,aASnBuG,SARUqC,MAAKb,uBASff,WARY4B,MAAKd,8BAgB3BN,wBAAAhF,UAAA2G,YAAA,WACI5B,KAVKoB,mBAeTnB,wBAAAhF,UAAAmG,gBAAA,WACQpB,KAZKuB,iBAaPvB,KAZKuB,gBAAgBM,yCAGpB5B,yBAAP6B,aACEC,KAAMC,cAYRA,UAZmBC,OAajBzJ,SAZU,kEAIXyH,wBAADiC,eAAC,WAAA,QAeAH,KAAMI,cAAPA,aACCJ,KAAMK,cAAPA,UAZOnC,wBAAPoC,gBAeAlC,WAde4B,KAAMO,cAcrBA,SACAjC,aAdiB0B,KAAMO,cAcvBA,SACAhC,yBAd6ByB,KAAMQ,cAcnCA,QACAhC,2BAd+BwB,KAAMQ,cAcrCA,QACA/B,yBAd6BuB,KAAMQ,cAcnCA,QACA9B,yBAd6BsB,KAAMQ,cAcnCA,QACA7B,0BAd8BqB,KAAMQ,cAcpCA,QACA9J,eAdmBsJ,KAAMQ,cAczBA,QACA5B,iBAdqBoB,KAAMQ,cAc3BA,QACA/D,aAdiBuD,KAAMQ,cAcvBA,QACA3I,iBAdqBmI,KAAMQ,cAc3BA,QACA5J,WAdeoJ,KAAMQ,cAcrBA,QC/HA,IAAAC,sBAAA,WAAA,QAAAA,uDAE2CA,sBAA3CV,aACEC,KAAMU,cAFRA,SAEkBR,OADhBS,cAEczC,yBADd0C,SAES1C,yBADT2C,WACAC,iBAMDL,qBAADN,eAAC,WAAA"}