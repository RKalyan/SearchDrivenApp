import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/sampleTime';
import { Observable } from 'rxjs/Observable';

/**
 * @param {?} selector
 * @param {?} scrollWindow
 * @param {?} defaultElement
 * @param {?} fromRoot
 * @return {?}
 */
function resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {
    const /** @type {?} */ hasWindow = window && !!window.document && window.document.documentElement;
    let /** @type {?} */ container = hasWindow && scrollWindow ? window : defaultElement;
    if (selector) {
        const /** @type {?} */ containerIsString = selector && hasWindow && typeof selector === 'string';
        container = containerIsString
            ? findElement(selector, defaultElement.nativeElement, fromRoot)
            : selector;
        if (!container) {
            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');
        }
    }
    return container;
}
/**
 * @param {?} selector
 * @param {?} customRoot
 * @param {?} fromRoot
 * @return {?}
 */
function findElement(selector, customRoot, fromRoot) {
    const /** @type {?} */ rootEl = fromRoot ? window.document : customRoot;
    return rootEl.querySelector(selector);
}
/**
 * @param {?} prop
 * @return {?}
 */
function inputPropChanged(prop) {
    return prop && !prop.firstChange;
}
/**
 * @return {?}
 */
function hasWindowDefined() {
    return typeof window !== 'undefined';
}

class AxisResolver {
    /**
     * @param {?=} vertical
     */
    constructor(vertical = true) {
        this.vertical = vertical;
    }
    /**
     * @return {?}
     */
    clientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }
    /**
     * @return {?}
     */
    offsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }
    /**
     * @return {?}
     */
    scrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }
    /**
     * @return {?}
     */
    pageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }
    /**
     * @return {?}
     */
    offsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }
    /**
     * @return {?}
     */
    scrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }
    /**
     * @return {?}
     */
    topKey() { return this.vertical ? 'top' : 'left'; }
}

/**
 * @param {?} __0
 * @return {?}
 */
function shouldTriggerEvents({ alwaysCallback, shouldFireScrollEvent }) {
    return (alwaysCallback || shouldFireScrollEvent);
}
/**
 * @param {?} callbacks
 * @param {?} isScrollingDown
 * @param {?} scrolledUntilNow
 * @return {?}
 */
function triggerEvents(callbacks, isScrollingDown, scrolledUntilNow) {
    const /** @type {?} */ eventData = {
        currentScrollPosition: scrolledUntilNow
    };
    const /** @type {?} */ callback = isScrollingDown ? callbacks.down : callbacks.up;
    callback(eventData);
}

/**
 * @param {?} __0
 * @return {?}
 */
function createResolver({ windowElement, axis }) {
    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);
}
/**
 * @param {?} resolver
 * @param {?} windowElement
 * @return {?}
 */
function createResolverWithContainer(resolver, windowElement) {
    const /** @type {?} */ container = resolver.isWindow || (windowElement && !windowElement.nativeElement)
        ? windowElement
        : windowElement.nativeElement;
    return Object.assign({}, resolver, { container });
}
/**
 * @param {?} windowElement
 * @return {?}
 */
function isElementWindow(windowElement) {
    const /** @type {?} */ isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));
    return isWindow;
}
/**
 * @param {?} isContainerWindow
 * @param {?} windowElement
 * @return {?}
 */
function getDocumentElement(isContainerWindow, windowElement) {
    return isContainerWindow ? windowElement.document.documentElement : null;
}
/**
 * @param {?} element
 * @param {?} resolver
 * @return {?}
 */
function calculatePoints(element, resolver) {
    const /** @type {?} */ height = extractHeightForElement(resolver);
    return resolver.isWindow
        ? calculatePointsForWindow(height, element, resolver)
        : calculatePointsForElement(height, element, resolver);
}
/**
 * @param {?} height
 * @param {?} element
 * @param {?} resolver
 * @return {?}
 */
function calculatePointsForWindow(height, element, resolver) {
    const { axis, container, isWindow } = resolver;
    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);
    // scrolled until now / current y point
    const /** @type {?} */ scrolledUntilNow = height +
        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);
    // total height / most bottom y point
    const /** @type {?} */ nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);
    const /** @type {?} */ totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +
        nativeElementHeight;
    return { height, scrolledUntilNow, totalToScroll };
}
/**
 * @param {?} height
 * @param {?} element
 * @param {?} resolver
 * @return {?}
 */
function calculatePointsForElement(height, element, resolver) {
    const { axis, container } = resolver;
    // perhaps use container.offsetTop instead of 'scrollTop'
    const /** @type {?} */ scrolledUntilNow = container[axis.scrollTopKey()];
    const /** @type {?} */ totalToScroll = container[axis.scrollHeightKey()];
    return { height, scrolledUntilNow, totalToScroll };
}
/**
 * @param {?} axis
 * @return {?}
 */
function extractHeightPropKeys(axis) {
    return {
        offsetHeightKey: axis.offsetHeightKey(),
        clientHeightKey: axis.clientHeightKey()
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function extractHeightForElement({ container, isWindow, axis }) {
    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);
    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);
}
/**
 * @param {?} elem
 * @param {?} isWindow
 * @param {?} offsetHeightKey
 * @param {?} clientHeightKey
 * @return {?}
 */
function getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {
    if (isNaN(elem[offsetHeightKey])) {
        return getDocumentElement(isWindow, elem)[clientHeightKey];
    }
    else {
        return elem[offsetHeightKey];
    }
}
/**
 * @param {?} elem
 * @param {?} axis
 * @param {?} isWindow
 * @return {?}
 */
function getElementOffsetTop(elem, axis, isWindow) {
    const /** @type {?} */ topKey = axis.topKey();
    // elem = elem.nativeElement;
    if (!elem.getBoundingClientRect) {
        // || elem.css('none')) {
        return;
    }
    return (elem.getBoundingClientRect()[topKey] +
        getElementPageYOffset(elem, axis, isWindow));
}
/**
 * @param {?} elem
 * @param {?} axis
 * @param {?} isWindow
 * @return {?}
 */
function getElementPageYOffset(elem, axis, isWindow) {
    const /** @type {?} */ pageYOffset = axis.pageYOffsetKey();
    const /** @type {?} */ scrollTop = axis.scrollTopKey();
    const /** @type {?} */ offsetTop = axis.offsetTopKey();
    if (isNaN(window[pageYOffset])) {
        return getDocumentElement(isWindow, elem)[scrollTop];
    }
    else if (elem.ownerDocument) {
        return elem.ownerDocument.defaultView[pageYOffset];
    }
    else {
        return elem[offsetTop];
    }
}

/**
 * @param {?} container
 * @param {?} config
 * @param {?} scrollingDown
 * @return {?}
 */
function shouldFireScrollEvent(container, config, scrollingDown) {
    const /** @type {?} */ distance = config.distance;
    let /** @type {?} */ remaining;
    let /** @type {?} */ containerBreakpoint;
    if (scrollingDown) {
        remaining = (container.totalToScroll - container.scrolledUntilNow) / container.totalToScroll;
        containerBreakpoint = distance.down / 10;
    }
    else {
        remaining = container.scrolledUntilNow / container.totalToScroll;
        containerBreakpoint = distance.up / 10;
    }
    const /** @type {?} */ shouldFireEvent = remaining <= containerBreakpoint;
    return shouldFireEvent;
}
/**
 * @param {?} lastScrollPosition
 * @param {?} container
 * @return {?}
 */
function isScrollingDownwards(lastScrollPosition, container) {
    return lastScrollPosition < container.scrolledUntilNow;
}
/**
 * @param {?} lastScrollPosition
 * @param {?} container
 * @param {?} config
 * @return {?}
 */
function getScrollStats(lastScrollPosition, container, config) {
    const /** @type {?} */ isScrollingDown = isScrollingDownwards(lastScrollPosition, container);
    return {
        shouldFireScrollEvent: shouldFireScrollEvent(container, config, isScrollingDown),
        isScrollingDown
    };
}
/**
 * @param {?} position
 * @param {?} scrollState
 * @return {?}
 */
function updateScrollPosition(position, scrollState) {
    return (scrollState.lastScrollPosition = position);
}
/**
 * @param {?} totalToScroll
 * @param {?} scrollState
 * @return {?}
 */
function updateTotalToScroll(totalToScroll, scrollState) {
    scrollState.lastTotalToScroll = scrollState.totalToScroll;
    scrollState.totalToScroll = totalToScroll;
}
/**
 * @param {?} scrollState
 * @return {?}
 */
function isSameTotalToScroll(scrollState) {
    return scrollState.totalToScroll === scrollState.lastTotalToScroll;
}
/**
 * @param {?} scrollState
 * @param {?} triggered
 * @return {?}
 */
function updateTriggeredFlag(scrollState, triggered) {
    scrollState.isTriggeredTotal = triggered;
}
/**
 * @param {?} scrollState
 * @param {?} scrolledUntilNow
 * @param {?} totalToScroll
 * @return {?}
 */
function updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {
    updateScrollPosition(scrolledUntilNow, scrollState);
    updateTotalToScroll(totalToScroll, scrollState);
    const /** @type {?} */ isSameTotal = isSameTotalToScroll(scrollState);
    if (!isSameTotal) {
        updateTriggeredFlag(scrollState, false);
    }
}

/**
 * @param {?} config
 * @return {?}
 */
function createScroller(config) {
    const { scrollContainer, scrollWindow, element, fromRoot } = config;
    const /** @type {?} */ resolver = createResolver({
        axis: new AxisResolver(!config.horizontal),
        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)
    });
    const /** @type {?} */ stats = calculatePoints(element, resolver);
    const /** @type {?} */ scrollState = {
        lastScrollPosition: 0,
        lastTotalToScroll: 0,
        totalToScroll: stats.totalToScroll,
        isTriggeredTotal: false
    };
    const /** @type {?} */ options = {
        container: resolver.container,
        mergeMap: () => calculatePoints(element, resolver),
        scrollHandler: (positionStats) => handleOnScroll(scrollState, positionStats, config),
        throttleDuration: config.throttle
    };
    return attachScrollEvent(options);
}
/**
 * @param {?} options
 * @return {?}
 */
function attachScrollEvent(options) {
    return Observable.fromEvent(options.container, 'scroll')
        .sampleTime(options.throttleDuration)
        .mergeMap((ev) => Observable.of(options.mergeMap(ev)))
        .subscribe(options.scrollHandler);
}
/**
 * @param {?} scrollState
 * @param {?} positionStats
 * @param {?} config
 * @return {?}
 */
function handleOnScroll(scrollState, positionStats, config) {
    const /** @type {?} */ distance = {
        down: config.downDistance,
        up: config.upDistance
    };
    const { isScrollingDown, shouldFireScrollEvent: shouldFireScrollEvent$$1 } = getScrollStats(scrollState.lastScrollPosition, positionStats, { distance });
    const /** @type {?} */ scrollConfig = {
        alwaysCallback: config.alwaysCallback,
        shouldFireScrollEvent: shouldFireScrollEvent$$1
    };
    updateScrollState(scrollState, positionStats.scrolledUntilNow, positionStats.totalToScroll);
    const /** @type {?} */ shouldTrigger = shouldTriggerEvents(scrollConfig);
    if (shouldTrigger && !scrollState.isTriggeredTotal) {
        updateTriggeredFlag(scrollState, true);
        triggerEvents(config.events, isScrollingDown, positionStats.scrolledUntilNow);
    }
}

class InfiniteScrollDirective {
    /**
     * @param {?} element
     * @param {?} zone
     */
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        this.scrolled = new EventEmitter();
        this.scrolledUp = new EventEmitter();
        this.infiniteScrollDistance = 2;
        this.infiniteScrollUpDistance = 1.5;
        this.infiniteScrollThrottle = 300;
        this.infiniteScrollDisabled = false;
        this.infiniteScrollContainer = null;
        this.scrollWindow = true;
        this.immediateCheck = false;
        this.horizontal = false;
        this.alwaysCallback = false;
        this.fromRoot = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.infiniteScrollDisabled) {
            this.setup();
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {
        const /** @type {?} */ containerChanged = inputPropChanged(infiniteScrollContainer);
        const /** @type {?} */ disabledChanged = inputPropChanged(infiniteScrollDisabled);
        const /** @type {?} */ distanceChanged = inputPropChanged(infiniteScrollDistance);
        const /** @type {?} */ shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||
            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;
        if (containerChanged || disabledChanged || distanceChanged) {
            this.destroyScroller();
            if (shouldSetup) {
                this.setup();
            }
        }
    }
    /**
     * @return {?}
     */
    setup() {
        if (hasWindowDefined()) {
            this.zone.runOutsideAngular(() => {
                this.disposeScroller = createScroller({
                    fromRoot: this.fromRoot,
                    alwaysCallback: this.alwaysCallback,
                    disable: this.infiniteScrollDisabled,
                    downDistance: this.infiniteScrollDistance,
                    element: this.element,
                    events: {
                        // tslint:disable-next-line:arrow-parens
                        down: event => this.zone.run(() => this.scrolled.emit(event)),
                        // tslint:disable-next-line:arrow-parens
                        up: event => this.zone.run(() => this.scrolledUp.emit(event))
                    },
                    horizontal: this.horizontal,
                    scrollContainer: this.infiniteScrollContainer,
                    scrollWindow: this.scrollWindow,
                    throttle: this.infiniteScrollThrottle,
                    upDistance: this.infiniteScrollUpDistance
                });
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyScroller();
    }
    /**
     * @return {?}
     */
    destroyScroller() {
        if (this.disposeScroller) {
            this.disposeScroller.unsubscribe();
        }
    }
}
InfiniteScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'
            },] },
];
/**
 * @nocollapse
 */
InfiniteScrollDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
];
InfiniteScrollDirective.propDecorators = {
    'scrolled': [{ type: Output },],
    'scrolledUp': [{ type: Output },],
    'infiniteScrollDistance': [{ type: Input },],
    'infiniteScrollUpDistance': [{ type: Input },],
    'infiniteScrollThrottle': [{ type: Input },],
    'infiniteScrollDisabled': [{ type: Input },],
    'infiniteScrollContainer': [{ type: Input },],
    'scrollWindow': [{ type: Input },],
    'immediateCheck': [{ type: Input },],
    'horizontal': [{ type: Input },],
    'alwaysCallback': [{ type: Input },],
    'fromRoot': [{ type: Input },],
};

class InfiniteScrollModule {
}
InfiniteScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InfiniteScrollDirective],
                exports: [InfiniteScrollDirective],
                imports: [],
                providers: []
            },] },
];
/**
 * @nocollapse
 */
InfiniteScrollModule.ctorParameters = () => [];

/**
 * Angular library starter.
 * Build an Angular library compatible with AoT compilation & Tree shaking.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular-library-starter
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { InfiniteScrollDirective, InfiniteScrollModule };
//# sourceMappingURL=ngx-infinite-scroll.js.map
